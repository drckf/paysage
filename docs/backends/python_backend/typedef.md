# Documentation for Typedef (typedef.py)

## class NumpyTensor
ndarray(shape, dtype=float, buffer=None, offset=0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strides=None, order=None)<br /><br />An array object represents a multidimensional, homogeneous array<br />of fixed-size items.  An associated data-type object describes the<br />format of each element in the array (its byte-order, how many bytes it<br />occupies in memory, whether it is an integer, a floating point number,<br />or something else, etc.)<br /><br />Arrays should be constructed using `array`, `zeros` or `empty` (refer<br />to the See Also section below).  The parameters given here refer to<br />a low-level method (`ndarray(...)`) for instantiating an array.<br /><br />For more information, refer to the `numpy` module and examine the<br />methods and attributes of an array.<br /><br />Parameters<br />----------<br />(for the __new__ method; see Notes below)<br /><br />shape : tuple of ints<br />&nbsp;&nbsp;&nbsp;&nbsp;Shape of created array.<br />dtype : data-type, optional<br />&nbsp;&nbsp;&nbsp;&nbsp;Any object that can be interpreted as a numpy data type.<br />buffer : object exposing buffer interface, optional<br />&nbsp;&nbsp;&nbsp;&nbsp;Used to fill the array with data.<br />offset : int, optional<br />&nbsp;&nbsp;&nbsp;&nbsp;Offset of array data in buffer.<br />strides : tuple of ints, optional<br />&nbsp;&nbsp;&nbsp;&nbsp;Strides of data in memory.<br />order : {'C', 'F'}, optional<br />&nbsp;&nbsp;&nbsp;&nbsp;Row-major (C-style) or column-major (Fortran-style) order.<br /><br />Attributes<br />----------<br />T : ndarray<br />&nbsp;&nbsp;&nbsp;&nbsp;Transpose of the array.<br />data : buffer<br />&nbsp;&nbsp;&nbsp;&nbsp;The array's elements, in memory.<br />dtype : dtype object<br />&nbsp;&nbsp;&nbsp;&nbsp;Describes the format of the elements in the array.<br />flags : dict<br />&nbsp;&nbsp;&nbsp;&nbsp;Dictionary containing information related to memory use, e.g.,<br />&nbsp;&nbsp;&nbsp;&nbsp;'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.<br />flat : numpy.flatiter object<br />&nbsp;&nbsp;&nbsp;&nbsp;Flattened version of the array as an iterator.  The iterator<br />&nbsp;&nbsp;&nbsp;&nbsp;allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for<br />&nbsp;&nbsp;&nbsp;&nbsp;assignment examples; TODO).<br />imag : ndarray<br />&nbsp;&nbsp;&nbsp;&nbsp;Imaginary part of the array.<br />real : ndarray<br />&nbsp;&nbsp;&nbsp;&nbsp;Real part of the array.<br />size : int<br />&nbsp;&nbsp;&nbsp;&nbsp;Number of elements in the array.<br />itemsize : int<br />&nbsp;&nbsp;&nbsp;&nbsp;The memory use of each array element in bytes.<br />nbytes : int<br />&nbsp;&nbsp;&nbsp;&nbsp;The total number of bytes required to store the array data,<br />&nbsp;&nbsp;&nbsp;&nbsp;i.e., ``itemsize * size``.<br />ndim : int<br />&nbsp;&nbsp;&nbsp;&nbsp;The array's number of dimensions.<br />shape : tuple of ints<br />&nbsp;&nbsp;&nbsp;&nbsp;Shape of the array.<br />strides : tuple of ints<br />&nbsp;&nbsp;&nbsp;&nbsp;The step-size required to move from one element to the next in<br />&nbsp;&nbsp;&nbsp;&nbsp;memory. For example, a contiguous ``(3, 4)`` array of type<br />&nbsp;&nbsp;&nbsp;&nbsp;``int16`` in C-order has strides ``(8, 2)``.  This implies that<br />&nbsp;&nbsp;&nbsp;&nbsp;to move from element to element in memory requires jumps of 2 bytes.<br />&nbsp;&nbsp;&nbsp;&nbsp;To move from row-to-row, one needs to jump 8 bytes at a time<br />&nbsp;&nbsp;&nbsp;&nbsp;(``2 * 4``).<br />ctypes : ctypes object<br />&nbsp;&nbsp;&nbsp;&nbsp;Class containing properties of the array needed for interaction<br />&nbsp;&nbsp;&nbsp;&nbsp;with ctypes.<br />base : ndarray<br />&nbsp;&nbsp;&nbsp;&nbsp;If the array is a view into another array, that array is its `base`<br />&nbsp;&nbsp;&nbsp;&nbsp;(unless that array is also a view).  The `base` array is where the<br />&nbsp;&nbsp;&nbsp;&nbsp;array data is actually stored.<br /><br />See Also<br />--------<br />array : Construct an array.<br />zeros : Create an array, each element of which is zero.<br />empty : Create an array, but leave its allocated memory unchanged (i.e.,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it contains "garbage").<br />dtype : Create a data-type.<br /><br />Notes<br />-----<br />There are two modes of creating an array using ``__new__``:<br /><br />1. If `buffer` is None, then only `shape`, `dtype`, and `order`<br />   are used.<br />2. If `buffer` is an object exposing the buffer interface, then<br />   all keywords are interpreted.<br /><br />No ``__init__`` method is needed because the array is fully initialized<br />after the ``__new__`` method.<br /><br />Examples<br />--------<br />These examples illustrate the low-level `ndarray` constructor.  Refer<br />to the `See Also` section above for easier ways of constructing an<br />ndarray.<br /><br />First mode, `buffer` is None:<br /><br />>>> np.ndarray(shape=(2,2), dtype=float, order='F')<br />array([[ -1.13698227e+002,   4.25087011e-303],<br />&nbsp;&nbsp;&nbsp;&nbsp;   [  2.88528414e-306,   3.27025015e-309]])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #random<br /><br />Second mode:<br /><br />>>> np.ndarray((2,), buffer=np.array([1,2,3]),<br />...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset=np.int_().itemsize,<br />...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtype=int) # offset = 1*itemsize, i.e. skip first element<br />array([2, 3])


## class Double
Double-precision floating-point number type, compatible with Python `float`<br />and C ``double``.<br />Character code: ``'d'``.<br />Canonical name: ``np.double``.<br />Alias: ``np.float_``.<br />Alias *on this platform*: ``np.float64``: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.


## class Dtype
dtype(obj, align=False, copy=False)<br /><br />Create a data type object.<br /><br />A numpy array is homogeneous, and contains elements described by a<br />dtype object. A dtype object can be constructed from different<br />combinations of fundamental numeric types.<br /><br />Parameters<br />----------<br />obj<br />&nbsp;&nbsp;&nbsp;&nbsp;Object to be converted to a data type object.<br />align : bool, optional<br />&nbsp;&nbsp;&nbsp;&nbsp;Add padding to the fields to match what a C compiler would output<br />&nbsp;&nbsp;&nbsp;&nbsp;for a similar C-struct. Can be ``True`` only if `obj` is a dictionary<br />&nbsp;&nbsp;&nbsp;&nbsp;or a comma-separated string. If a struct dtype is being created,<br />&nbsp;&nbsp;&nbsp;&nbsp;this also sets a sticky alignment flag ``isalignedstruct``.<br />copy : bool, optional<br />&nbsp;&nbsp;&nbsp;&nbsp;Make a new copy of the data-type object. If ``False``, the result<br />&nbsp;&nbsp;&nbsp;&nbsp;may just be a reference to a built-in data-type object.<br /><br />See also<br />--------<br />result_type<br /><br />Examples<br />--------<br />Using array-scalar type:<br /><br />>>> np.dtype(np.int16)<br />dtype('int16')<br /><br />Structured type, one field name 'f1', containing int16:<br /><br />>>> np.dtype([('f1', np.int16)])<br />dtype([('f1', '<i2')])<br /><br />Structured type, one field named 'f1', in itself containing a structured<br />type with one field:<br /><br />>>> np.dtype([('f1', [('f1', np.int16)])])<br />dtype([('f1', [('f1', '<i2')])])<br /><br />Structured type, two fields: the first field contains an unsigned int, the<br />second an int32:<br /><br />>>> np.dtype([('f1', np.uint), ('f2', np.int32)])<br />dtype([('f1', '<u4'), ('f2', '<i4')])<br /><br />Using array-protocol type strings:<br /><br />>>> np.dtype([('a','f8'),('b','S10')])<br />dtype([('a', '<f8'), ('b', '|S10')])<br /><br />Using comma-separated field formats.  The shape is (2,3):<br /><br />>>> np.dtype("i4, (2,3)f8")<br />dtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])<br /><br />Using tuples.  ``int`` is a fixed type, 3 the field's shape.  ``void``<br />is a flexible type, here of size 10:<br /><br />>>> np.dtype([('hello',(int,3)),('world',np.void,10)])<br />dtype([('hello', '<i4', 3), ('world', '|V10')])<br /><br />Subdivide ``int16`` into 2 ``int8``'s, called x and y.  0 and 1 are<br />the offsets in bytes:<br /><br />>>> np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))<br />dtype(('<i2', [('x', '|i1'), ('y', '|i1')]))<br /><br />Using dictionaries.  Two fields named 'gender' and 'age':<br /><br />>>> np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})<br />dtype([('gender', '|S1'), ('age', '|u1')])<br /><br />Offsets in bytes, here 0 and 25:<br /><br />>>> np.dtype({'surname':('S25',0),'age':(np.uint8,25)})<br />dtype([('surname', '|S25'), ('age', '|u1')])


## class Float
Single-precision floating-point number type, compatible with C ``float``.<br />Character code: ``'f'``.<br />Canonical name: ``np.single``.<br />Alias *on this platform*: ``np.float32``: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.


## class Byte
Unsigned integer type, compatible with C ``unsigned char``.<br />Character code: ``'B'``.<br />Canonical name: ``np.ubyte``.<br />Alias *on this platform*: ``np.uint8``: 8-bit unsigned integer (0 to 255).


## class Long
Signed integer type, compatible with Python `int` anc C ``long``.<br />Character code: ``'l'``.<br />Canonical name: ``np.int_``.<br />Alias *on this platform*: ``np.int64``: 64-bit signed integer (-9223372036854775808 to 9223372036854775807).<br />Alias *on this platform*: ``np.intp``: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.


## class Int
Signed integer type, compatible with C ``int``.<br />Character code: ``'i'``.<br />Canonical name: ``np.intc``.<br />Alias *on this platform*: ``np.int32``: 32-bit signed integer (-2147483648 to 2147483647).

